function TLdist = calcTLTdist(varargin)
% Calculates the Touschek lifetime for of a number of 
% lattice variants that differ only through the application of a 
% given error model (and possibly corresponding corrections)
% Tracking can be 6d or 4d  as defined by the input lattice. 
%
% This is a higher level wrapper function
% that in turn calls the calcLMA_dist and calcTLT_raw functions.
% Linear optics parameters; expects a full ring as input, but may choose 
% only one achromat for the Local Momentum Aperture (LMA) calculations
%
%% Inputs
% Mandatory arguments
%  RING : AT2.0 lattice cell array.
%  ErrorModel: structure generated by the errormodel function : 
%              if empty default is 
%              errormodel_DDRchallenging('gdran',0.0,'magalran',1.0,...
%                                'mulsys',0.0, 'mulran',1.0,...
%                                'bpmran', 0.0, 'strran', 0.0);
% ***************************************************
%  TLoptions: structure with Touschek lifetime calculation options,
%            containing the following fields (if empty, default values are set) : 
%
%  TLoptions.Ib : current per bunch [A],. default = 0.5/176
%  TLoptions.integrationmethod : see calcTLT_raw, default =
%                                               'integral'
%  TLoptions.abstol: absolute tolerance, default  = 1.0e-16
%  TLoptions.reltol: relative tolerance, default  = 1.0e-16
%  TLoptions.nperiods: number of periods, default = 20
%  TLoptions.LMAperiods: number of periods for which to calculate the LMA, default = 1;
%  TLoptions.kcoupl: coupling ratio, if = 'auto', calculated from the
%                                   vertical emittance, default = 'auto'
% TLoptions.emity : vertical emittance, if kcoupl not 'auto', calculated from the coupling ratio, 
%                   default =8.0E-12 [m rad]
%
% ************************************
%  MAoptions: structure with local momentum aperture calculation options,
%             containing the following fields (if empty, default values are set)
% 
%  MAoptions: structure with ocal momentm aperture calculation
%                         options, with fields:
%
%  MAoptions.lmafams: cell array of strings with names of magnet families at which LMA
%                     is to be calculated. If = 'all' then all non-zero length elements are included           = 'all';
%  MAoptions.stepfam: specifies only one every stepfam elements are included
%  MAoptions.deltalimit: maximum momentum deviation to be searched. Used to establish the rf bucket height.
%  MAoptions.initcoord: initial coordinates [x0 y0]
%  MAoptions.delta: initial guess for momentum aperture 
%  MAoptions.deltastepsize: step size for LMA search
%  MAoptions.splits: number of iterations of step division
%  MAoptions.split_step_divisor: factor to reduce step size at each iteration
%  MAoptions.nturns: number of turns. If nan then number of turns
%                             is chosen as 1.2/Qs, default = 1024
%  MAoptions.S0max: maximum longitudinal position at which to calculate LMA [m], 
%                            default if RING is available = findspos(cLOptions.RING,length(cLOptions.RING)+1)/20;
%                            default if RING is not available = 528/20
%  MAoptions.S0min: minimum longitudinal position at which to
%                            calculate LMA [m], default = 0.0
%
% *************************************************************************
% Optional arguments
%
% all fields in MAoptions
% all fields in TLoptions
% 
% corrorb: if true, perform orbit correction
% corrtun: if true, perform tune correction
%
% nseeds: number of seeds, default = 10
% tunfams : list of magnet families used for ring tun matching, default = {'Q1_b3','Q2_b3'}
% nittune : number of iterations for tune matching, default = 10
% TolTune : tolerance for tune matching, default = 1E-3
% frac    : fraction for quad change in each tune fit iteration, defaut = 1.0
%
% verbose : defines level of verbose output, default=0, i.e. no output
% LMAdist : momentum aperture structure generated by calcLMAdist. if
%                 available, LMA calculation can be skipped
% Optional flags
% corrorb: perform orbit correction
% corrtun: perform tune correction
% fulloutput : includes detailed data all data on each one of seeds.
%
%% Outputs
% TLdist : structure with the fields
%   TLdist.inputs echoes the input
%   TLdist.inputs.RING 
%
%   TLdist.inputs.TLoptions
%   TLdist.inputs.MAoptions
%
%   TLdist.inputs.nseeds
%   TLdist.inputs.tunfams 
%   TLdist.inputs.nittune 
%   TLdist.inputs.TolTune 
%   TLdist.inputs.frac
% 
%   TLdist.outputs structure with fields
%
%   TLdist.outputs.LMAdist: local momentum aperture structure  - for
%                           details see calcLMAdist
%   TLdist.outputs.emitx  : horzontal emittance [mrad]
%   TLdist.outputs.emity  : vertical emittance [mrad]
%   TLdist.outputs.sigmap : momentum spread
%   TLdist.outputs.sigmas : bunch length [m]
%   TLdist.outputs.TLs: (1Xnseeds+1) array of Touschek lifetimes for all 
%                       seeds. First point is the unperturbed lattice [s].
%   TLdist.outputs.TLav: Average Touschek lifetime [s]
%   TLdist.outputs.TLstd: Standard Deviation of Touschek lifetimes [s]
%
%   TLdist.outputs.telapsed: elapsed calculation time [s]
%
%% Usage Examples
% TLTdist=calcTLTdist(RINGGRD_a1,[],TLoptions,MAoptions,'verbose',2,'tunfams',{'Q1_a1';'Q2_a1'},'nseeds',10);

%% History
% PFT 2024/06/26 first version
% PFT 2024/07/05 cleanup/documentation
% PFT 2024/07/21 : added possibility of using existing LMAdist structure 
%                  as input. If available, LMA calculation can be skipped
% PFT 2024/07/23 : improved handling of unstable lattices (removed from mean
%                  values)
%
%% Input argument parsing
[RING,ErrorModel,TLoptions,MAoptions]= getargs(varargin,[],[],[],[]);

if (isempty(ErrorModel))
    ErrorModel=errormodel_DDRchallenging('gdran',1.0,'magalran',1.0,...
                                         'mulsys',1.0, 'mulran',1.0,...
                                         'bpmran', 1.0, 'strran', 1.0);
end

if isempty(TLoptions)
    TLoptions.Ib = 0.5/176;
    TLoptions.integrationmethod = 'integral';
    TLoptions.abstol = 1.0e-16;
    TLoptions.reltol = 1.0e-16;
    TLoptions.nperiods = 20;
    TLoptions.LMAperiods = 1;
    TLoptions.kcoupl = 'auto';
    TLoptions.emity  = 8.0E-12;
end

verboselevel  = getoption(varargin,'verbose',0);
Ib = getoption(varargin,'Ib',TLoptions.Ib);
integrationmethod = getoption(varargin,'integrationmethod',TLoptions.integrationmethod);
abstol = getoption(varargin, 'AbsTol', TLoptions.abstol);
reltol = getoption(varargin, 'Relol', TLoptions.reltol);
nperiods = getoption(varargin,'nperiods',TLoptions.nperiods);
LMAperiods = getoption(varargin,'LMAperiods',TLoptions.LMAperiods);
kcoupl = getoption(varargin,'kcoupl',TLoptions.kcoupl);
emity  = getoption(varargin,'emity',TLoptions.emity);
LMAdist = getoption(varargin,'LMAdist', struct());
   
TLoptions.Ib=Ib;
TLoptions.integrationmethod = integrationmethod;
TLoptions.abstol = abstol;
TLoptions.reltol = reltol;
TLoptions.nperiods = nperiods;
TLoptions.LMAperiods = LMAperiods;
TLoptions.kcoupl = kcoupl;
TLoptions.emity  = emity;

if (isempty(MAoptions))
   MAoptions.lmafams='all';
   MAoptions.stepfam=1;
   MAoptions.deltalimit=0.1;
   MAoptions.initcoord=[0.0 0.0 0.0 0.0 0.0 0.0]';
   MAoptions.delta=0.01;
   MAoptions.deltastepsize=0.001;
   MAoptions.splits=10;
   MAoptions.split_step_divisor=2;
   MAoptions.nturns=500;
   MAoptions.S0max=528/20;
   MAoptions.S0min=0.0;
end

lmafams            = getoption(varargin,'lmafams',MAoptions.lmafams);
stepfam            = getoption(varargin,'stepfam',MAoptions.stepfam);
deltalimit         = getoption(varargin,'deltalimit',MAoptions.deltalimit);
initcoord          = getoption(varargin,'initcoord',MAoptions.initcoord);
delta              = getoption(varargin,'delta',MAoptions.delta);
deltastepsize      = getoption(varargin,'deltastepsize',MAoptions.deltastepsize);
splits             = getoption(varargin,'splits',MAoptions.splits);
split_step_divisor = getoption(varargin,'split_step_divisor',MAoptions.split_step_divisor);
nturns             = getoption(varargin,'nturns',MAoptions.nturns);
S0max              = getoption(varargin,'S0max', MAoptions.S0max);
S0min              = getoption(varargin,'S0min', MAoptions.S0min);

MAoptions.lmafams    = lmafams;
MAoptions.stepfam    = stepfam;
MAoptions.deltalimit = deltalimit;
MAoptions.initcoord  = initcoord;
MAoptions.delta      = delta;
MAoptions.deltastepsize =  deltastepsize;
MAoptions.splits     = splits;
MAoptions.split_step_divisor = split_step_divisor;
MAoptions.nturns             = nturns;
MAoptions.S0max              = S0max;
MAoptions.S0min              = S0min;

corrorbf        = getoption(varargin,'corrorb',true);
corrtunf        = getoption(varargin,'corrtun',true);
fulloutputf     = any(strcmpi(varargin,'fulloutput'));

nseeds           = getoption(varargin,'nseeds',10);
tunfams          = getoption(varargin,'tunfams',{'Q1_b3','Q2_b3'});
nittune          = getoption(varargin,'nittune',10); % max n. of iterations for tune matching
TolTune          = getoption(varargin,'TolTune',1E-3); % tolerance for tune matching
frac             = getoption(varargin,'frac',1.0); % fraction for quad change in each tune fit iteration

%% Preamble
if (verboselevel>0)
    fprintf('**** \n');
    fprintf('%s calcTLTdist: starting - calculating atsummary \n', datetime);
end

tstart=tic;
energy=RING{1}.Energy;
Periodicity=RING{1}.Periodicity;
circumference = findspos(RING,length(RING)+1)*Periodicity;
period = circumference/nperiods;
ats = atsummary(RING);
if (ischar(kcoupl))
    if(strcmpi(kcoupl,'auto'))
        kcoupln = (emity/ats.naturalEmittance)*(1-emity/ats.naturalEmittance);
    else
        kcoupln = 0.025;
        emity = ats.naturalEmittance*kcoupln/(1+kcoupln);    
    end
else
    kcoupln = kcoupl;
    emity = ats.naturalEmittance*kcoupl/(1+kcoupl); 
end

emitx = ats.naturalEmittance/(1+kcoupln);
sigp  = ats.naturalEnergySpread;
sigs  = ats.bunchlength;
deltalimit = ats.energyacceptance;

S0min = 0.0;
S0max = LMAperiods*period;


%% Calculates LMAdist
if (isempty(fields(LMAdist)))
    if (verboselevel>0)
        fprintf('%s CalcTLTdist: Starting LMA distribution calculation \n', datetime);
    end

    if (fulloutputf)
        LMAdist = calcLMAdist(RING,ErrorModel,MAoptions,'corrorb',corrorbf,...
                      'corrtun',corrtunf,'S0max',S0max,'S0min',S0min,...
                      'deltalimit',deltalimit,'tunfams',tunfams,...
                      'nseeds',nseeds,'verbose', verboselevel-1,'fulloutput');
    else
        LMAdist = calcLMAdist(RING,ErrorModel,MAoptions,'corrorb',corrorbf,...
                      'corrtun',corrtunf,'S0max',S0max,'S0min',S0min,...
                      'deltalimit',deltalimit,'tunfams',tunfams,...
                      'nseeds',nseeds,'verbose', verboselevel-1);
    end
else
    if (verboselevel>0)
        fprintf('%s CalcTLTdist: Using previously calculated LMA distribution \n', datetime);
    end
    if(nseeds~=LMAdist.inputs.nseeds)
        nseeds = LMAdist.inputs.nseeds;
        fprintf('%s CalcTLTdist Warning: nseeds chamged to %3d \n', datetime, nseeds);
    end
end

if (verboselevel>0)
     fprintf('%s CalcTLTdist: Starting Touschek lifetime caculation \n', datetime);
end

Ipos  = LMAdist.outputs.Ipos;
TLs=zeros(1,nseeds+1);
map_lT=LMAdist.outputs.map_l;
map_hT=LMAdist.outputs.map_h;

%% Calculates Touschek lifetimes
parfor i=1:nseeds+1
    if (verboselevel>0)
        fprintf('%s CalcTLTdist: Seed n %3d \n', datetime, i-1);
    end
    map_l = map_lT(i,:);
    map_h = map_hT(i,:);
    lmap=cat(2,map_h',map_l');
    [~,lindata] = atlinopt4(RING,Ipos);
    for j=1:length(lindata)
        lindata(j).Length = RING{Ipos(j)}.Length;
    end

    TLs(i) = calcTLT_raw(lindata,lmap,'Ib',Ib,'circumference',circumference,'energy',energy,'emitx',emitx,'emity',emity,...
          'sig',sigp,'sigs',sigs,'abstol',abstol,'reltol', reltol, 'integrationmethod', ...
          integrationmethod,'verbose',verboselevel-2);
end
TLav  = mean(TLs,'omitnan');
TLstd = std(TLs,'omitnan');

%% Collects output structure data
TLdist.inputs.RING =RING;
TLdist.inputs.ErrorModel = ErrorModel;
TLdist.inputs.nseeds     = nseeds;
TLdist.inputs.tunfams    = tunfams;
TLdist.inputs.nittune    = nittune;
TLdist.inputs.TolTune    = TolTune;
TLdist.inputs.frac       = frac;
TLdist.inputs.corrorbf   = corrorbf;
TLdist.inputs.corrtunf   = corrtunf;
TLdist.inputs.MAoptions=MAoptions;
TLdist.inputs.TLoptions=TLoptions;

TLdist.outputs.LMAdist = LMAdist;
TLdist.outputs.emitx   = emitx;
TLdist.outputs.emity   = emity;
TLdist.outputs.sigmap  = sigp;
TLdist.outputs.sigmas  = sigs;
TLdist.outputs.TLs = TLs;
TLdist.outputs.TLav = TLav;
TLdist.outputs.TLstd = TLstd;
TLdist.outputs.telapsed=toc(tstart);

