function TMdist = calcTMdist(varargin)
% Calculates a series of Tune Maps for a number of 
% lattice variants that differ only through the application of a given 
% error model (and possibly corresponding corrections).
%
% This is a higher level wrapper function
% that in turn calls the lower level function "calcTuneMap"
% 
%% Inputs
% Mandatory arguments
% RING : AT2 lattice array
% ErrorModel: structure generated by the errormodel function : 
%              if empty default is 
%              errormodel_DDRchallenging('gdran',0.0,'magalran',1.0,...
%                                'mulsys',0.0, 'mulran',1.0,...
%                                'bpmran', 0.0, 'strran', 0.0);
%
% TMoptions: structure with fields (if TMoptions is empty, defaults are
%                                   used. any specific fields may be
%                                   changed by entering an optional
%                                   argument)
%  TMoptions.mode: (default is 'x'):
%  'x'      calculates only tunes vs horizontal position at minimum
%           vertical position (minampy)
%  'y'      calculates only tunes vs vertical position at minimum
%           horizontal position (minampx)
%  'xy'     calculates both x and y as described above
%  'gridxy' calculates tunes on a grid of points in (x,y) plane.
%  'gridxdp'calculates tunes on a grid of points in (x,dp) plane
%  'gridydp'calculates tunes on a grid of points in (x,dp) plane
%  'difxy'  calculates tune diffusion map in the xy plane 
%               tune calculation method is 4 (NAFF). 
%  'difxdp' calculates tune diffusion map in the xdp plane
%               tune calculation method is 4 (NAFF). 
%  'difydp' calculates tune diffusion map in the ydp plane 
%               tune calculation method is 4 (NAFF). 
%  'chrom' calculates chromatic tune footprint.
%
%  TMoptions.minampx: minimum absolute value of amplitude in horizontal direction,
%            default=30 microm
%  TMoptions.minampy: minimum absolute value of amplitude in horizontal direction,
%            default=30 microm
%  TMoptions.xmax: max horizontal amplitude [m], default = 0.005 
%  TMoptions.xmin: min horizontal amplitude [m], default = 0.0 
%       
%  TMoptions.ymax: max vertical amplitude [m], default = 0.004
%  TMoptions.ymin: min vertical amplitude [m], default = 0.0
% 
%  TMoptions.dpmax: max energy deviation for chromatic tune footprint,default = +0.03
%  TMoptions.dpmin: min energy deviation for chromatic tune footprint,default = -0.03
%
%  TMoptions.xmax_dm: max horizontal amplitude [m] for diffusion maps, default = 0.005 
%  TMoptions.xmin_dm: min horizontal amplitude [m] for diffusion maps, default = 0.0 
%  TMoptions.ymax_dm: max vertical amplitude [m], default = 0.004
%  TMoptions.ymin_dm: min vertical amplitude [m], default = 0.0
%  TMoptions.dpmax_dm: max energy deviation for chromatic tune footprint,default = +0.03
%  TMoptions.dpmin_dm: min energy deviation for chromatic tune footprint,default = -0.03
%
%  TMoptions.dp: initial energy deviation, default = 0.0
%
%  TMoptions.npx: number of points along horizontal direction; default = 11
%  TMoptions.npy: number of points along vertical direction: default = 11
%  TMoptions.npd: number of points along energy axis: default = 11
%  TMoptions.nturns : number of turns, default = 128
%
%  TMoptions.method 1: Highest peak in fft
%                   2: Interpolation on fft results
%                   3: Windowing + interpolation (default)
%                   4: NAFF (this is always the method in case the mode is "diff"
%
%  TMoptions.smooth  : if true, selects smooth mode grid calculations - note that this means 
%           computations are not parallelized. This is only relevant for
%           method=4 (NAFF), deafult = false
%
% Optional arguments
% Any of the fields in the TMoptions structure
% desc: descriptive string
%
%   ERlat: structure generated by the "generate_errlatt" function. If not
%   available or empty this structure is generated in this function by a
%   call to "generate_errlatt".
%
%   corrorb: if true, perform orbit correction
%   corrtun: if true, perform tune correction
%   useORM0   : if true, sets the orbit correction to use the orbit respose
%               matrix for the unperturbed ring for all iterations, 
%               default=true
%
%   nseeds: number of seeds, default = 10
%   tunfams : list of magnet families used for ring tun matching, default = {'Q1_b3','Q2_b3'}
%   nittune : number of iterations for tune matching, default = 10
%   TolTune : tolerance for tune matching, default = 1E-3
%   frac    : fraction for quad change in each tune fit iteration, defaut = 1.0
%
%   verboselevel : defines level of verbose output, default=0, i.e. no output
%
% fulloutput : includes detailed data all data on each one of seeds.
%
%% Outputs
% TMdist structure with fields
%   TMdist.inputs echoes the inputs
%   TMdist.inputs.RING : input ring array
%   TMdist.inputs.ErrorModel 
%   TMdist.inputs.nseeds 
%   TMdist.inputs.tunfams 
%   TMdist.inputs.nittune 
%   TMdist.inputs.TolTune 
%   TMdist.inputs.frac
%   TMdist.inputs.corrorbf : correct orbit flag
%   TMdist.inputs.corrtunf : correct tune flag
%
%   TMdist.outputs.desc : : datetime + input description
%   TMdist.outputs.TMoptions : TMoptions actually used for the calculations
%   TMdist.outputs.TMs: (1Xnseeds+1) array of tune map structures
%   TMdist.outputs.orb0_stds: (6Xnseeds+1) array of close orbit standadr
%                           deviations for perturbed lattices before 
%                           correction. First point is the unperturbed
%                           lattice.
%   TMdist.outputsorb_stds  = (6Xnseeds+1) array of close orbit standard
%                           deviations for perturbed lattices after 
%                           correction. First point is the unperturbed
%                           lattice.
% Note: the outptus (RINGe,raparae,Itunese and Ftunese) below are empty 
%       unless the 'fulloutput' option is on
%   TMdist.outputs.RINGe:  (nseeds+1Xsize of RING) cell array of perturbed 
%                        lattices after correction. first is the
%                        unperturbed lattice.
%   TMdist.outputs.rparae: (nseeds+1X1) cell array of atsummaries for
%                        perturbed lattices after correction. 
%                        First is the unperturbed lattice.
%   TMdist.outputs.Itunese:(nseeds+1X1) cell array of tunes for the 
%                         perturbed lattices before correction
%                         First is the unperturbed lattice.
%   TMdist.outputs.Ftunese: (nseeds+1X1) cell array of tunes for the 
%                         perturbed lattices after correction
%                         First is the unperturbed lattice.
%
%
%   TMdist.outputs.telapsed: calculation time [s]
%
%% Usage examples
% TMdist = calcTuneMapdist(RING,ErrorModel,TMoptions,'corrorb',true,'verbose', 1);
% TMdist = calcTuneMapdist(RING,ErrorModel,[],'nturns',1024,'corrorb',true);
% calcTuneMapdist(RING,ErrorModel,[],'nturns',1024,'nseeds',10);
% TMdist = calcTuneMapdist(RING,ErrorModel,[],'nturns',810,'tunfams',{'Q1','Q2'},'frac',0.5);
% TMdist = calcTuneMapdist(RING,ErrorModel,[],'mode,'xy','nturns',810,'tunfams',{'Q1','Q2'});

%% History
% PFT 2024/07/13: first version, derived from calcDAdist
% PFT 2024/07/15: fixed bug for choice of lattice with errors
% SJ  2024/07/29: replaced code for error generation and correction by
%                 call to "generate_errlatt".
%                 added possibility of input of ERlat structure
%                 added possibility of fixing the response matrix for all
%                 seeds.
% PFT 2024/08/05: fixed bug - incorrect initilization of output vectors
%                 if the number of seeds was larger than the default (10)
% PFT 2024/08/06: fixed bug, incorrect initialization
%
%% Input argument parsing
[RING,ErrorModel,TMoptions] = getargs(varargin,[],[],[]);
if (isempty(ErrorModel))
    ErrorModel=errormodel_DDRchallenging('gdran',0.0,'magalran',1.0,...
                                         'mulsys',0.0, 'mulran',1.0,...
                                         'bpmran', 0.0, 'strran', 0.0);
end

ERlat =  getoption(varargin,'Erlat',struct());

if (isempty(TMoptions))
   TMoptions.mode='x';
   TMoptions.npx = 11;
   TMoptions.npy = 11;
   TMoptions.npd = 11;
   TMoptions.xmin = -0.006;
   TMoptions.xmax = +0.006;
   TMoptions.ymin = 0.0;
   TMoptions.ymax = 0.004;
   TMoptions.xmin_dm = -0.006;
   TMoptions.xmax_dm = +0.006;
   TMoptions.ymin_dm = 0.0;
   TMoptions.ymax_dm = 0.004;
   TMoptions.dp   = 0.0;
   TMoptions.dpmin = -0.04;
   TMoptions.dpmax = +0.04;
   TMoptions.dpmin_dm = -0.04;
   TMoptions.dpmax_dm = +0.04;
   TMoptions.nturns = 1024;
   TMoptions.minampx = 30E-6;
   TMoptions.minampy = 30E-6;
   TMoptions.method = 4;
   TMoptions.smooth = false;
end

fulloutputf      = any(strcmpi(varargin,'fulloutput'));
corrorbf         = getoption(varargin,'corrorb',true);
corrtunf         = getoption(varargin,'corrtun',true);
verboselevel     = getoption(varargin,'verbose',0);
useORM0f         = getoption(varargin,'useORM0',true);
desc             = getoption(varargin,'desc','Tune map calculation');
%
smooth           = getoption(varargin,'smooth',TMoptions.smooth);
nturns           = getoption(varargin,'nturns',TMoptions.nturns);
mode             = getoption(varargin,'mode',TMoptions.mode);
minampx          = getoption(varargin,'minampx',TMoptions.minampx);
minampy          = getoption(varargin,'minampy',TMoptions.minampy);
xmax             = getoption(varargin,'xmax', TMoptions.xmax);
xmin             = getoption(varargin,'xmin',TMoptions.xmin);
ymax             = getoption(varargin,'ymax',TMoptions.ymax);
ymin             = getoption(varargin,'ymin',TMoptions.ymin);
xmax_dm          = getoption(varargin,'xmax_dm', TMoptions.xmax_dm);
xmin_dm          = getoption(varargin,'xmin_dm',TMoptions.xmin_dm);
ymax_dm          = getoption(varargin,'ymax_dm',TMoptions.ymax_dm);
ymin_dm          = getoption(varargin,'ymin_dm',TMoptions.ymin_dm);
dp               = getoption(varargin,'dp',TMoptions.dp);
dpmin            = getoption(varargin,'dpmin',TMoptions.dpmin);
dpmax            = getoption(varargin,'dpmax',TMoptions.dpmax);
dpmin_dm         = getoption(varargin,'dpmin_dm',TMoptions.dpmin_dm);
dpmax_dm         = getoption(varargin,'dpmax_dm',TMoptions.dpmax_dm);
npx              = getoption(varargin,'npx',TMoptions.npx);
npy              = getoption(varargin,'npy',TMoptions.npy);
npd              = getoption(varargin,'npd',TMoptions.npd);
method           = getoption(varargin,'method',TMoptions.method);

TMoptions.smooth   = smooth;
TMoptions.nturns   = nturns;
TMoptions.mode     = mode;
TMoptions.minampx  = minampx;
TMoptions.minampy  = minampy;
TMoptions.xmax     = xmax;
TMoptions.xmin     = xmin;
TMoptions.ymax     = ymax;
TMoptions.ymin     = ymin;
TMoptions.xmax_dm  = xmax_dm;
TMoptions.xmin_dm  = xmin_dm;
TMoptions.ymax_dm  = ymax_dm;
TMoptions.ymin_dm  = ymin_dm;
TMoptions.dp       = dp;
TMoptions.dpmin    = dpmin;
TMoptions.dpmax    = dpmax;
TMoptions.dpmin_dm = dpmin_dm;
TMoptions.dpmax_dm = dpmax_dm;
TMoptions.npx      = npx;
TMoptions.npy      = npy;
TMoptions.npd      = npd;
TMoptions.method   = method;

nseeds           = getoption(varargin,'nseeds',10);
tunfams          = getoption(varargin,'tunfams',{'Q1_b3','Q2_b3'});
nittune          = getoption(varargin,'nittune',10); % max n. of iterations for tune matching
TolTune          = getoption(varargin,'TolTune',1E-3); % tolerance for tune matching
frac             = getoption(varargin,'frac',1.0); % fraction for quad change in each tune fit iteration

%% Preamble
tstart= tic;
if (verboselevel>0)
    fprintf('*** \n');
    fprintf('%s Starting Tune Map distribution calculation, mode =  %s \n', ...
            datetime, TMoptions.mode );
end

if (verboselevel>0)
   fprintf('%s Calculating unperturbed lattice parameters \n', datetime);
end

try
   rpara  = atsummary(RING);
   Itunes = rpara.Itunes;
  
catch ME
     fprintf('%s Error in calcTuneMapdist \n', datetime);
     fprintf('Error message was:%s \n',ME.message);
     TMdist.inputs.RING=RING;
     TMdist.inputs.ErrorModel=ErrorModel;
     TMdist.outputs.TMs=TMs;
     TMdist.outputs.orb0_stds=orb0_stds;
     TMdist.outputs.orb_stds=orb_stds;
     TMdist.outputs.RINGe=RINGe;
     TMdist.outputs.rparae=rparae;
     TMdist.outputs.Itunese=Itunesse;
     telapsed=toc(tstart);
     TMdist.outputs.telapsed=telapsed;
     return
end

%% Generates or reads lattices with errors
if (isempty(fields(ERlat)))
    ERlat = generate_errlatt(RING,ErrorModel,'tunfams',tunfams, ...
    'nseeds',nseeds,'nittune', nittune, 'TolTune', TolTune,...
    'frac', frac, 'useORM0', useORM0f, 'verbose', verboselevel-1);
else
    if (verboselevel>0)
        fprintf('%s calcTMdist: using previously calculated corrected lattices \n', datetime);
    end
    nseeds    = min(nseeds,ERlat.inputs.nseeds);
    corrorbf  = ERlat.inputs.corrorbf;
    corrtunf  = ERlat.inputs.corrtunf;
    useORM0f  = ERlat.inputs.useORM0f;
    tunfams   = ERlat.inputs.tunfams;
    nittune   = ERlat.inputs.nittune;
    TolTune   = ERlat.inputs.TolTune; 
    frac      = ERlat.inputs.frac;
end
RINGe        = ERlat.outputs.RINGe;
orb0_stds    = ERlat.outputs.orb0_stds;
orb_stds     = ERlat.outputs.orb_stds;
stab         = ERlat.outputs.stab;

if (not(isempty(ERlat.outputs.rparae{1})))
   rpara = ERlat.outputs.rparae{1};
else
     fprintf('%s Error in calcTMdist: unperturned ring is unstable \n', datetime);
     TMdist.inputs.RING=RING;
     TMdist.inputs.ErrorModel=ErrorModel;
     TMdist.outputs.orb0_stds=orb0_stds;
     TMdist.outputs.orb_stds=orb_stds;
     TMdist.outputs.RINGe=RINGe;
     TMdist.outputs.rparae=rparae;
     TMdist.outputs.Itunese=Itunesse;
     telapsed=toc(tstart);
     TMdist.outputs.telapsed=telapsed;
     return
end

TMs=cell(nseeds+1,1);
for i=1:nseeds+1
    TMs{i}=struct();
end

rparae  = cell(nseeds+1,1);
Itunese = cell(nseeds+1,1);
Ftunese = cell(nseeds+1,1);

if (verboselevel>0)
    fprintf('*** \n');
    fprintf('%s Starting Tune Map calculations \n', datetime);
end

for i=1:nseeds+1
 if (verboselevel>0)
    fprintf('%s seed n. %3d \n', datetime, i-1);
 end
 if (stab(i))
  try
   tunemap = calcTuneMap(RINGe{i},TMoptions);
   TMs{i} = tunemap;
  catch ME
     fprintf('%s Error in calcTuneMapdist for seed n. %3d \n', datetime, i);
     fprintf('Error message was:%s \n',ME.message);
     TMs{i}=struct();
  end
 end
end

%% Collects output structure data
TMdist.inputs.RING=RING;
TMdist.inputs.ErrorModel=ErrorModel;
TMdist.inputs.mode=mode;
TMdist.inputs.nseeds=nseeds;
TMdist.inputs.corrorb=corrorbf;
TMdist.inputs.corrtun=corrtunf;
TMdist.inputs.nittune=nittune;
TMdist.inputs.TolTune=TolTune;
TMdist.inputs.tunfams=tunfams;
TMdist.inputs.frac=frac;

TMdist.outputs.desc=strcat(sprintf('%s',datetime),' : ', desc);
TMdist.outputs.TMoptions=TMoptions;
TMdist.outputs.TMs=TMs;
TMdist.outputs.orb0_stds=orb0_stds;
TMdist.outputs.orb_stds=orb_stds;
if (fulloutputf)
    TMdist.outputs.RINGe=RINGe;
    TMdist.outputs.rparae=rparae;
    TMdist.outputs.Itunese=Itunese;
    TMdist.outputs.Ftunese=Ftunese;
else
    TMdist.outputs.RINGe={};
    TMdist.outputs.rparae={};
    TMdist.outputs.Itunese={};
    TMdist.outputs.Ftunese={};
end

telapsed=toc(tstart);
TMdist.outputs.telapsed=telapsed;

if(verboselevel>0)
    fprintf('%s TMdist calculation complete \n', datetime);
end
