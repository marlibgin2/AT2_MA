function LinMatchR= LinMatch(varargin)
%
%   Performs linear lattice matching using several magnet families simultaneously
%   
%% inputs
% Mandatory inputs
% LatticeOptData : structure generated by m4U.m
% ACHRO: AT2 lattice cell array - one achromat
%
% Optional inputs
%  fitdispf : if present fits dispersion
%  tunes: target tunes for 20 achromats
%
%  dx: percent range around initial magnet strength values in whihc fits are searched
%
%% Input argument parsing
[LatticeOptData,ACHRO]=getargs(varargin,[],[]);
plotf          = any(strcmpi(varargin,'plot'));
fitucf         = any(strcmpi(varargin,'fituc'));
fitdispf       = any(strcmpi(varargin,'fitdisp')); 
fitbeta0f      = any(strcmpi(varargin,'fitbeta0')); 
fittunef       = any(strcmpi(varargin,'fittune'));
fitchromf      = any(strcmpi(varargin,'fitchrom')); 
fitemitf       = any(strcmpi(varargin,'fitemit'));
plotdaf        = any(strcmpi(varargin,'plotda')); 
tunescanf      = any(strcmpi(varargin,'tunescan'));
plottunescanf  = any(strcmpi(varargin,'plottunscan'));
saveOPAf       = any(strcmpi(varargin,'saveOPA'));
savef          = any(strcmpi(varargin,'save'));
verbosef       = any(strcmpi(varargin,'verbose'));

tunesuc        = getoption(varargin,'tunesuc',[3/7 1/7]);
emitrange      = getoption(varargin,'emitrange',[100 200]);
dx             = getoption(varargin,'dx',10);
lb             = getoption(varargin,'lb',[]);
ub             = getoption(varargin,'ub',[]);
nitfit         = getoption(varargin,'nitfit',100);
nittune        = getoption(varargin,'nittune',LatticeOptData.nittune);
nitdisp        = getoption(varargin,'nitdisp',LatticeOptData.nitdisp);
nitAlpha       = getoption(varargin,'nitAlpha',LatticeOptData.nitAlpha);
TolTune        = getoption(varargin,'TolTune',LatticeOptData.TolTune);
TolDisp        = getoption(varargin,'TolDisp',LatticeOptData.TolDisp);
TolAlpha       = getoption(varargin,'TolAlpha',LatticeOptData.TolAlpha);
TolX           = getoption(varargin,'TolX',1E-9);
TolLinFit      = getoption(varargin,'TolLinFit',1E-9);
minfunc        = getoption(varargin,'minfunc','fminsearch');% fmincon
verboselevel   = getoption(varargin,'verboselevel',0);

betas0         = getoption(varargin,'betas0',[9.0 2.0]);
tunes          = getoption(varargin,'tunes',[46.20 16.28]);
Qrange         = getoption(varargin,'IQrange',[46 47 15 18]);
qrange         = getoption(varargin,'qrange',[0.1 0.4 0.1 0.4]);
Npq            = getoption(varargin,'Npq',[10 10]);
DAoptions      = getoption(varargin,'DAoptions',LatticeOptData.DAoptions);
chroms0        = getoption(varargin,'chroms0',DAoptions.chroms0);
Nitchro        = getoption(varargin,'nitchro',DAoptions.Nitchro);
TolChrom       = getoption(varargin,'TolChrom',DAoptions.TolChrom);


%% preamble
ACHRO_fit     = ACHRO;
isdipole      = LatticeOptData.isdipole;
LinMatch_fams = LatticeOptData.LinMatch_fams;
LM_stdfamlist    = LatticeOptData.LM_stdfamlist; 
LM_nstdfamlist   = LatticeOptData.LM_nstdfamlist; 
nLMfams       = size(LinMatch_fams,1);
All_fams      = LatticeOptData.All_fams;
nallfams      = LatticeOptData.nallfams;
dTheta        = LatticeOptData.Trb;

ILinMa = zeros(nLMfams);
I_famsAllF  = LatticeOptData.IfamsAllF;
for i=1:nLMfams
    ILinMa(i)=find(strcmp(All_fams,LinMatch_fams{i}));
end
X0 = getLinMatch(2,ACHRO,LatticeOptData);
if (~isnan(dx))
    lb = X0 - abs(X0)*dx/100;
    ub = X0 + abs(X0)*dx/100;
end
  
%% Sets up matching variables
    %Variables=cell(nLMfams,1);
    for i=1:length(LM_stdfamlist)
        Variables(i) = atVariableBuilder(ACHRO,LinMatch_fams{LM_stdfamlist(i)},...
               {'PolynomB',{1,2}}, X0(LM_stdfamlist(i)),lb(LM_stdfamlist(i)),ub(LM_stdfamlist(i))); 
    end
    
    for i=1:length(LM_nstdfamlist)
        Variables(i+length(LM_stdfamlist)) = atVariableBuilder(@(R,K)setLinMatch(2,R,LatticeOptData,...
                            cat(2,nan(1,LM_nstdfamlist(i)-1),K,nan(1,nLMfams-LM_nstdfamlist(i)))),...
                            X0(LM_nstdfamlist(i)),lb(LM_nstdfamlist(i)),ub(LM_nstdfamlist(i)));
                            
    end

%% Sets up dispersion matching
if (fitdispf)
    if (verbosef)
        fprintf('Setting up dispersion matching... \n');
    end
   Constr1  = atlinconstraint(1,{{'Dispersion',{1}}},0,0,1);
else
   Constr1 = [];
end
%% Sets up ring tune matching
if (fittunef)
    if (verbosef)
        fprintf('Setting up ring tunes matching... \n');
    end
    Qxfit = tunes(1);
    Qyfit = tunes(2);
    %qxfit = FractionalPart(Qxfit/20)*(2*pi);
    %qyfit = FractionalPart(Qyfit/20)*(2*pi);
    qxfit=Qxfit/20;
    qyfit=Qyfit/20;
    %Constr2  = atlinconstraint(length(ACHRO)+1,{{'mu',{1}}},qxfit,qxfit,1);
    %Constr3  = atlinconstraint(length(ACHRO)+1,{{'mu',{2}}},qyfit,qyfit,1);
    Constr2 = struct('Fun',{@(~,ld,~)mux(ld),@(~,ld,~)muy(ld)},...
                'Min',{qxfit,qyfit},'Max',{qxfit,qyfit},...
                'RefPoints',{1:length(ACHRO)+1,1:length(ACHRO)+1},...
                'Weight',{1,1});

else
   Constr2 = [];
end
%% Sets up emittance matching
if (fitemitf)
    if (verbosef)
        fprintf('Setting up emittance matching... \n');
    end
    Constr3 = struct('Fun',@(ACHRO,~,~)emitx(ACHRO,isdipole),...
                'Min',emitrange(1),'Max',emitrange(2),...
                'RefPoints',[],...
                'Weight',1);
else
    Constr3 =[];
end

Constraints=[Constr1,Constr2,Constr3];
  
%% Do Linear Matching    
if (not(isempty(Constraints)))
    if (verbosef)
        fprintf('Performing lattice matching...\n');
        tic;
    end
    fh = str2func(minfunc);
    [ACHRO_fit, Penalty, ~] = atmatch_mod(ACHRO,Variables,Constraints,...
                         TolLinFit,TolX, nitfit,verboselevel,fh,'UseParallel',true);   
    
    if (verbosef)
        fprintf('Linear lattice matched with penalty = %6.2e \n', sum(Penalty.^2));
        toc;
    end
    
    for i=1:nLMfams
        K_fam = atgetfieldvalues(ACHRO_fit, I_famsAllF{ILinMa(i)}, 'PolynomB', {1,2});
        Kall_new(ILinMa(i))=K_fam(1);
        ACHRO_fit = atsetfieldvalues(ACHRO_fit, I_famsAllF{ILinMa(i)}, 'K', K_fam); % makes sure K and PolynomB are the same
    end

    try
        ringpar=atsummary_fast(ACHRO_fit,isdipole);
    catch ME
        fprintf('Error in atsummary of full period after dispersion fit \n');
        fprintf('Error message was:%s \n',ME.message);
        Dialog = questdlg('Revert lattice ?','Yes', 'No');
        switch Dialog
            case 'Yes'
                ACHRO_fit = ACHRO;
                Kall_new=Kall_old;
                fprintf('Lattice reverted \n');
            case 'No'
        end % switch 
    end
else
    fprintf('No linear match constraints requested; Proceeding with input lattice \n');
end

%% Plots matched lattice Functions
if (plotf)
    try
      figure;atplot(ACHRO_fit);title('fitted lattice'); %TBC adjust colors to mnatch OPA plots
    catch ME
        fprintf('Error in atplot of final lattice \n');
        fprintf('Error message was: %s \n',ME.message);
    end
end

%% Matches chromaticity 
%
if(fitchromf&&~isempty(chrom_fams))
    ACHRO_old=ACHRO_fit;
     if (verbosef) 
      fprintf('Fitting Chromaticity... \n'); 
     end
     try 
        [ACHRO_fit, Penalty_chro, its]=fitchroit(ACHRO_fit, chrom_fams, chroms0, Nitchro, TolChrom); 
        I_sc1  = find(atgetcells(ACHRO_fit, 'FamName', chrom_fams{1}));
        K_sc1  = atgetfieldvalues(ACHRO_fit, I_sc1, 'PolynomB', {3});
        I_sc2  = find(atgetcells(ACHRO_fit, 'FamName', chrom_fams{2}));
        K_sc2  = atgetfieldvalues(ACHRO_fit, I_sc2, 'PolynomB', {3});
        Sc1    = K_sc1(1);
        Sc2    = K_sc2(1);
        Penalty= sqrt(Penalty^2  + sum(Penalty_chro.^2));
        if (verbosef)
            fprintf('Chromaticity matched with penalty = %6.2e in %2d iterations\n', Penalty, its);
        end
            X0_new    = getAllfams(2,ACHRO_fit,LatticeOptData);
            ACHRO_fit = setAllfams(2,ACHRO_fit,LatticeOptData,X0_new);
     catch ME
        fprintf('Error in DetAChroMatch: chromaticity fit \n');
        fprintf('Error message was: %s \n',ME.message);
        ACHRO_fit = ACHRO_old;
     end
     
     try
        rpara=atsummary_fast(ACHRO_fit,isdipole);
     catch ME
        fprintf('Error in atsummary of full period after chromaticity fit \n');
        fprintf('Error message was: %s \n',ME.message);
        Sc1=NaN;
        Sc2=NaN;
    end    
else
    Sc1=NaN;
    Sc2=NaN;
end

%% Calculates and Plots the Dynamic Aperture
%
if (plotdaf)
    DA=CalcPlotDA(ACHRO_fit,DAoptions,'plot');
    fprintf('Dynamic Aperture = %4.2f mm**2 \n',DA);
else
    DA=NaN;
end
%% Collects data
if (verbosef)
    disp('Calculating optics parameters for the final lattice...');
    tic;
end
try
    ringpara=atsummary_fast(ACHRO_fit,LatticeOptData.isdipole);
catch ME
    fprintf('Error in atsummary of Full achromat lattice \n');
    fprintf('Error message was: %s \n',ME.message);
    ringpara.circ=NaN;
    ringpara.naturalEmittance=NaN;
    ringpara.naturalEnergySpread=NaN;
    ringpara.tunes=[NaN NaN];
    ringpara.damping = [NaN NaN NaN];
    ringpara.chromaticity= [NaN NaN];
    ringpara.alphac = NaN;
    ringpara.Qx_ring = NaN;
    ringpara.Qy_ring = NaN;
    ringpara.beta0 = [NaN NaN];
    ringpara.etax0 = NaN;
end
if(verbosef)
    toc;
end
frf= 99.931e6;
dCirc = (ringpara.circ-528.0)*1000;
dfRF  = dCirc/528.0*frf/1000;
%unpkick = RbLength*Krb*yOffset;
%RbShift = (dTheta*1000 - unpkick)/RbLength/Krb;

Ksixring = ringpara.chromaticity(1)*20;
Ksiyring = ringpara.chromaticity(2)*20;

LinMatchR.inputs.Trb             = dTheta;
%LinMatchR.inputs.nojointfit      = nojointf;
LinMatchR.inputs.LatticeOptData  = LatticeOptData;
LinMatchR.inputs.tunesuc         = tunesuc;
LinMatchR.inputs.tunes           = tunes;
LinMatchR.inputs.TolX            = TolX;
LinMatchR.inputs.nittune         = nittune;
LinMatchR.inputs.nitAlpha        = nitAlpha;
LinMatchR.inputs.TolTune         = 'TolTune';
LinMatchR.inputs.TolDisp         = TolDisp;
LinMatchR.inputs.TolAlpha        = TolAlpha;

LinMatchR.inputs.lb              = lb;
LinMatchR.inputs.ub              = ub;
LinMatchR.inputs.fittunef        = fittunef;
LinMatchR.inputs.fitchromf       = fitchromf; 
LinMatchR.inputs.dx              = dx;
LinMatchR.inputs.lb              = lb;
LinMatchR.inputs.ub              = ub;
LinMatchR.inputs.tunes           = tunes; 

LinMatchR.inputs.chroms0         = chroms0;

LinMatchR.inputs.Nitchro        = Nitchro;
LinMatchR.inputs.TolChrom       = TolChrom;

LinMatchR.outputs.ringpars       = ringpara;
LinMatchR.outputs.ringpars.dfRF  = dfRF;
%LinMatchR.outputs.ringpars.yOffset  = yOffset;
%DetMatchR.outputs.ringpara.unpkick  = unpkick;
%DetMatchR.outputs.ringpara.RbShitf  = RbShift;
LinMatchR.outputs.ringpars.Ksixring = Ksixring;
LinMatchR.outputs.ringpars.Ksiyring = Ksiyring;
LinMatchR.outputs.Penalty = Penalty;
LinMatchR.outputs.XAll  = Kall_new;
LinMatchR.outputs.ACHROMAT= ACHRO_fit;


%% Saves OPA file
if(saveOPAf)
   RunNumber = strcat('LinMatch_',datestr(now,30));
   saveOPA(X0_new,[],[],LatticeOptData,RunNumber);
end
%% Saves results file
if(savef)
    filename = strcat('LinMatch_',datestr(now,30));
    LinMatchR.RunNumber = filename;
    fprintf('Saving file %s \n', filename);
    filename=strcat('LinearLatticeMatch/',filename);
    try
        save(filename,'LinMatchR');
    catch
        fprintf('%s Problems saving linear lattice match results file', datetime)
    end
end
%% Auxiliary functions
function fp=FractionalPart(x)
    fp=x-fix(x);
