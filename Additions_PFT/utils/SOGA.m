function SOGAResults = SOGA(varargin)
% Runs Single objective optimization of lattice parameters using genetic
% algorithm
% 
%% inputs:
%         optfnct : objective function to be minimized
%              LattOpt_DynAp :  on-momentum dynamic aperture
%              LattOpt_RDT   :  Resonant Driving Terms Penalty Function
%
%         constfnct: non-linear constraints function
%                    LimSext : limits strength of sextupoles used for
%                              chromaticity correction
%                    stabcon : checks for linear stability and maximum
%                               beta and dispersion  function
%                    None    : no constraints (except for the bounds of
%                                              decision variables)
%
%         lb: lower bounds (1xnvars) array, where nvars is the number of variable to vary
%         ub: upper bounds (1xnvars) array, where nvars is the number of variable to vary
%         PopSize: population size
%         FuncTol: Tolerance for stopping SOGA generations
%         MAXGens: Maximum number of generations
%         savef  : if 'Y', saves out structure onto a file in folder
%                "\SOGA_Scans" and automatically generated file name.
%         contf  : if 'Y' assumes this is a continuation run and uses the
%                final population of a previus run (selected from a dialog box) as
%                the initial popultion for this run. Otherwise the initial population is generated acording
%                to the choice indicated below in "options"
%         X0_Lin : Linear lattice decision variables - only relevant for
%                  "SEXT" optmization mode.
%         LatticeOptData : generated by the function max4_UpgradeStudies.
%         SMax   : maximum absolute sextupole strength for chromativity
%                  correction sextupoles. Used only when the constrain 
%                  function is LimSext
% 
% NOTE 1: This function should only be called when the optimzation function returns
% a single objective.
%
% NOTE 2: Various options of the minimization algorithm can be chosen 
% by modifying the calls to optimoptions below
%
%% Input Argument Parsing
[LatticeOptData, X0_Lin, optfnct]=getargs(varargin,[],[],'LattOpt_EmitDynAp');
constfnct      = getoption(varargin,'constfnct','None');
X0             = getoption(varargin,'X0',[]);
dx             = getoption(varargin,'dx',[]);
PopSize        = getoption(varargin,'PopSize',100);
FuncTol        = getoption(varargin,'FuncTol', 1E-9);
MaxGens        = getoption(varargin,'MaxGens', 100);
SMax           = getoption(varargin, 'SMax', 300);
lb             = getoption(varargin,'lb',[]);
ub             = getoption(varargin,'ub',[]);

savef          = any(strcmpi(varargin,'save'));
contf          = any(strcmpi(varargin,'cont'));
%% Preamble
nvars     = LatticeOptData.nvars;
scan_fams = LatticeOptData.scan_fams; 
optMode   = LatticeOptData.optMode;
lattMode  = LatticeOptData.lattMode;

Range = cat(1,lb,ub);

switch optfnct
    case 'LattOpt_DynAp'
        fitvars        = {'-DA[mm**2]'};
    case 'LattOpt_RDT' 
        fitvars        = {'RDT'};
    otherwise    
        fprintf('Invalid optimization function %s . Aborting .\n', optfnct);
        SOGAResults=[];
        return;
end
%
%% Checks compatibility between optimization mode and optimization function
%
switch optMode
   case {'Linear'}
           fprintf('Incompatible optimization function %s \n', optfnct);
           fprintf('for optimization mode %s \n', optMode);
           fprintf('Aborting...\n');
           SOGAResults=[];
           return
    case {'NonLinear','Full'}
        
   otherwise
       fprintf ('Invalid optimization mode. Aborting \n');
       SOGAResults=[];
       return
end

fprintf('\n');
fprintf('%s Starting SOGA Scan \n', datetime);
fprintf('Lattice Mode      = %s  \n', lattMode);
fprintf('Optimization Mode      = %s  \n', optMode);
fprintf('Optimization Function  = %s  \n', optfnct);
fprintf('Constraint Function    = %s  \n', constfnct);
fprintf('Decision Variables     = %s ,%s ,%s ,%s ,%s ,%s ,%s ,%s ,%s ,%s \n', ...
    scan_fams{1:length(scan_fams)});
fprintf('\n ----- \n');

if (size(X0,2)==nvars)
    lb = X0-abs(X0)*dx/100;
    ub = X0+abs(X0)*dx/100;
end

fprintf('lower bounds set to: ');
fprintf('%5.3f ', lb(1:nvars));
fprintf('\r\n');
fprintf('upper bounds set to: ');
fprintf('%5.3f ', ub(1:nvars));
fprintf('\r\n');

options = optimoptions('ga');

%% Modify options setting

% creation options
options = optimoptions(options,'CreationFcn', @gacreationuniform);
options = optimoptions(options,'InitialPopulationRange', Range);
%options = optimoptions(options,'CreationFcn', @gacreationlinearfeasible);
%options = optimoptions(options,'CreationFcn', @gacreationnonlinearfeasible);

% Mutation options

options = optimoptions(options,'MutationFcn', @mutationadaptfeasible);
%options = optimoptions(options,'MutationFcn', {@mutationgaussian, 1, 1});


% Crossover options
options = optimoptions(options,'CrossoverFcn',{@crossoverintermediate, 1});
options = optimoptions(options,'CrossoverFraction',0.8);

% Fitness Scaling Options
options = optimoptions(options,'FitnessScalingFcn',@fitscalingrank);
%options = optimoptions(options,'FitnessScalingFcn',@fitscalingprop);
%options = optimoptions(options,'FitnessScalingFcn',{@fitscalingtop,0.4});
%options = optimoptions(options,'FitnessScalingFcn',{@fitscalingshiftlinear, 2});


% Hybrid options
%hybridopts = optimoptions('fmincon','Display','iter');
%options = optimoptions(options,'HybridFcn',{'fmincon',hybridopts});

% Other options
options = optimoptions(options,'Display', 'iter');
options = optimoptions(options,'FunctionTolerance', FuncTol);
options = optimoptions(options,'MaxGenerations', MaxGens);
options = optimoptions(options,'PopulationSize', PopSize);
options = optimoptions(options,'UseParallel', true, 'UseVectorized', false);


% selection function

%options = optimoptions(options,'SelectionFcn', @selectionstochunif);
options = optimoptions(options,'SelectionFcn', {@selectiontournament,4});
%options = optimoptions(options,'SelectionFcn', @selectionroulette);
%options = optimoptions(options,'SelectionFcn', @selectionremainder);


if (strcmp(constfnct,'None'))
    options = optimoptions(options,'PlotFcn', {@gaplotbestf});
else
    options = optimoptions(options,'PlotFcn', {@gaplotbestf,@gaplotmaxconstr});
end

% if this is a continuation run, get the initial population from a previous
% SOGA result

if(contf)
    filename=uigetfile;
    if (ischar(filename))
        load(filename,'SOGAResults');
        if(isfield(SOGAResults.LatticeOptData,'optMode'))
            OldoptMode=SOGAResults.LatticeOptData.optMode;
        else
            OldoptMode='SIMP';
        end
    else
        fprintf('No file chosen. Aborting... \n');
        SOGAResults=[];
        return
    end
  
    if(not(strcmp(OldoptMode,optMode)))
        fprintf('Inconsistent optmization modes (%s to %s ) in continuation run. Aborting...\n',...
              OldoptMode, optMode);
        return
    else
        OldPopulation     = SOGAResults.Population;
        OldPopSize        = SOGAResults.PopSize;
        Oldnvars          = SOGAResults.LatticeOptData.nvars;
        mvars             = min(nvars,Oldnvars);
        mPopSize          = min(OldPopSize,PopSize);
        InitialPopulation = zeros(PopSize,nvars);
        for i=1:PopSize
            for j=1:nvars
                InitialPopulation(i,j) = (lb(j)+ub(j))/2;
            end
        end
        InitialPopulation(1:mPopSize,1:mvars)=OldPopulation(1:mPopSize,1:mvars);
        if(contf&&isfield(SOGAResults,'DVLins'))
            DVLins=SOGAResults.DVLins;
        else
            DVLins = X0_Lin;
        end
    end 
    
    options = optimoptions(options,'InitialPopulation', InitialPopulation);
    SOGAResults=[];
    SOGAResults.ContinuationRun='Yes';
    SOGAResults.PreviousRun=filename;
    fprintf ('Continuation run from:  %s \n', filename);
    fprintf ('Optmization Modes:      %s to %s \n', OldoptMode, optMode);
    fprintf ('Population:             %4d to %4d \n', OldPopSize, PopSize);
    fprintf ('Decision Variables:     %4d to %4d \n', Oldnvars, nvars);
else
    SOGAResults.ContinuationRun='No';
    SOGAResults.PreviousRun='';
    DVLins = X0_Lin;
end

%
%% sets fixed linear lattice parameters in case of pure sextupole
% optimization case 
%
if (strcmp(optMode,'NonLinear'))
  LatticeOptData.HACHRO = setLins(1,LatticeOptData.HACHRO,LatticeOptData,DVLins);
  LatticeOptData.ACHRO  = setLins(2,LatticeOptData.ACHRO,LatticeOptData,DVLins);
  LatticeOptData.UC     = setLins(3,LatticeOptData.UC,LatticeOptData,DVLins);
  LatticeOptData.RING   = setLins(5,LatticeOptData.RING,LatticeOptData,DVLins);
end

fh = str2func(optfnct);
LattOptfnct = @(x)fh(x,LatticeOptData);


ch = str2func(constfnct);

switch  constfnct
    case 'stabcon'
        Constfnct=@(x)ch(x,LatticeOptData);
    
    case 'LimSext'
        Constfnct=@(x)ch(x,LatticeOptData,SMax);

    case 'None'
        fprintf('Unconstrained otimization \n');
   
    otherwise
       fprintf ('Invalid Constraints function. Aborting \n');
       SOGAResults=[];
        return
end

%% Performs optmization
tic;   
% rng('default'); % for tests only makes it reproducible
if strcmp(constfnct,'None')
    [x,fval,exitflag,output,Population,scores] = ga(LattOptfnct,nvars,...
                                 [],[],[],[],lb,ub,[],options);
else
    [x,fval,exitflag,output,Population,scores] = ga(LattOptfnct,nvars,...
                                 [],[],[],[],lb,ub,Constfnct,options);
end

%% Collects results in output structure
SOGAResults.LatticeOptData=LatticeOptData;
SOGAResults.optfnct=optfnct;
SOGAResults.constfnct=constfnct;
switch constfnct
    case 'stabcon'
    SOGAResults.constraints = {'abs(Tr(Mx))<2';'abs(Tr(My))<2';...
                    strcat('BetaX<',num2str(LatticeOptData.BetaXMAX));...
                    strcat('BetaY<',num2str(LatticeOptData.BetaYMAX));...
                    strcat('EtaX0<',num2str(LatticeOptData.EtaX0MAX));...
                    strcat('abs(FractuneGoal_X-FracTuneX) < ',num2str(LatticeOptData.DeltaFracTuneX));...
                    strcat('abs(FractuneGoal_Y-FracTuneY) < ',num2str(LatticeOptData.DeltaFracTuneY));...
                    strcat('BetaY0 - BetaX0 < ', num2str(LatticeOptData.DBetaXY));...
                    strcat('BetaX0 < ', num2str(LatticeOptData.BetaX0Max));...
                    strcat('BetaY0 < ', num2str(LatticeOptData.BetaY0Max));...
                    strcat('Jx < 3.0 ')};

    case 'LimSext'
        SOGAResults.constraints = {strcat('abs(Sc1)<',num2str(SMax));
                    strcat('abs(Sc2)<',num2str(SMax))};
end
SOGAResults.options=options;
SOGAResults.fitvars=fitvars;
SOGAResults.FuncTol=FuncTol;
SOGAResults.MaxGens=MaxGens;
SOGAResults.PopSize=PopSize;
SOGAResults.exitflag=exitflag;
SOGAResults.output=output;
SOGAResults.Population=Population;
SOGAResults.scores=scores;
SOGAResults.score=fval;
SOGAResults.lb=lb;
SOGAResults.ub=ub;
SOGAResults.optDVs = x;

filename = strcat('SOGA_',datestr(now,30));
SOGAResults.RunNumber = filename;

if(strcmp(optMode,'NonLinear'))
    SOGAResults.DVLins=DVLins;
end

if(savef)
    fprintf('Saving file %s \n', filename);
    filename=strcat('SOGA_Scans/',filename); %needs changing for windows path conventions
    save(filename,'SOGAResults');
end

toc;


