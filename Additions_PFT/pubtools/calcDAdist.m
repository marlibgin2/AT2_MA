function DAdist = calcDAdist(varargin)
% Calculates and plots Dynamic Aperture of a number of 
% lattice variants that differ only through the application of a given error model
% Tracking can be 6d or 4d
% as defined by the input lattice. 
% This is a higher level wrapper function
% that in turn calls the lower level function "calcDA_raw"
% 
%% Inputs
% Mandatory arguments
% RING : AT2 lattice array
% ErrorModel: structure generated by the errormodel function : 
%              if empty default is errormodel_var('girdersc',0.0,'magalsc',1.0,'multsc',0.0);
% DAoptions: Structure containing the following fields:
%               DAmode   = 'grid' or 'border' (plots are only produced if
%                           DAmode is 'border'
%               nturns   : number of turns
%               betax0   : horizontal beta for normalization - if NaN, no normalization is done
%               betay0   : vertical beta for normalization - if NaN no normalization is done
%               xmaxdas  : limits of the range in which the DA border is searched
%               xmindas  : limits of the range in which the DA border is searched
%               ymaxdas  : limits of the range in which the DA border is searched
%
% Parameters for "border" DA calculation mode
%               r0      : initial guess [m]
%               nang    : number of angular steps
%               dp      : initial dp/p (6d tracking) or fixed dp/p (4d tracking)
%               z0      : initial longitudinal coordinate (6d tracking). Nan uses synchrnous phase
%               res     : resolution [m]
%               alpha   : da enlargement factor for border search
%
% Parameters for "grid" DA calculation mode
%               XmaxDA  : Horizontal range is -Xmax to Xmax [m]
%               YmaxDA  : Vertical range is 0 to Ymax [m]
%               npdax   : number of grid points in x direction is 2*npdax+1
%               npday   : number of grid points in y direction is  npday+
%
%
%            If DAoptions = [], hard-coded defaults are used.
%            Values of DAoptions fields are overridden if given explicitly 
%            as input in the form ('parameter', value)
%
% Optional arguments
%   all fields in DAoptions listed above
%   nseeds: number of seeds, default = 10
%   tunfams : list of magnet families used for ring tun matching, default = {'Q1_b3','Q2_b3'}
%   nittune : number of iterations for tune matching, defauke = 1000
%   TolTune : tolerance for tune matching, default = 1E-8
%
% Optional flags
% plot : plots DA;
% verbose: produces verbose output
% corrorb: perform orbit correction
% corrtun: perform tune correction
%
%% Outputs
% DAdist structure with fields
% DAdist.inputs.RING : input ring array
% DAdist.inputs.nseeds : n. of seeds
% DAdist.inputs.ErrorModel : error model structure
% DAdist.inputs.correctf=correctf;
%
% DAdist.outputs.DAoptions : DAoptions actually used for the calculations
% DAdist.outputs.DAav: Average Dynamic aperture [mm**2]
% DAdist.outputs.DAstd: DAStandard Deviation of Dynamics Apertures [mm**2]
% DAdist.outputs.DAVs=DAVs: Dynamic apeture for all seeds (only for
%                           DAMode='border'
%% Usage examples
% DAdist = calcDAdist(RING,ErrorModel,DAoptions,'plot','corrorb','verbose');
% DAdist = calcDAdist(RING,ErrorModel,[],'nturns',1024,'corrorb');
% calcDAdist(RING,ErrorModel,[],'nturns',1024,'nseeds',10,'plot','corrorb');
% DAdist = calcDAdist(RING,ErrorModel,[],'nturns',810,'corrorb','corrtun','tunfams',{'Q1','Q2'});

%% History
% PFT 2024/03/12
% PFT 2024/03/29: changed oputput to a structure, echoing also input
%                  parameters
% PFT 2024/04/23: added capabilty to fit tunes
% PFT 2024/04/27: added recording&plotting of rms orbit before and after correction
%
%% Input argument parsing
[RING,ErrorModel,DAoptions] = getargs(varargin,[],[],[]);
if (isempty(ErrorModel))
    ErrorModel=errormodel_DDRchallenging('gdran',0.0,'magalran',1.0,...
                                         'mulsys',0.0, 'mulran',1.0,...
                                         'bpmran', 0.0, 'strran', 0.0);
end
if (isempty(DAoptions))
    DAoptions.dp=0.0;
    DAoptions.z0=nan;
    DAoptions.DAmode='border';
    DAoptions.nturns=1024;
    DAoptions.betax0=nan;
    DAoptions.betay0=nan;
    DAoptions.xmaxdas=0.007;
    DAoptions.xmindas =-0.0150;
    DAoptions.ymaxdas = 0.006;
    DAoptions.XmaxDA = 0.015;
    DAoptions.YmaxDA = 0.007;
    DAoptions.npdax = 64;
    DAoptions.npday = 64;
    DAoptions.r0 = 0.020;
    DAoptions.nang = 20;
    DAoptions.res = 5E-4; 
    DAoptions.alpha = 1.1;
    DAoptions.dx=nan;
    DAoptions.dy=nan;
    DAoptions.dxdy=nan;
    DAoptions.npDA = (2*DAoptions.npdax+1)*(DAoptions.npday+1); %total number of grid points
    DAoptions.X0da = zeros(DAoptions.npDA,1);  % horizontal coordinates of grid points [m]
    DAoptions.Y0da = zeros(DAoptions.npDA,1);  % vertical coordinates of grid points [m]
end

plotf            = any(strcmpi(varargin,'plot'));
verbosef         = any(strcmpi(varargin,'verbose'));
corrorbf         = any(strcmpi(varargin,'corrorb'));
corrtunf         = any(strcmpi(varargin,'corrtun'));
plotorbrmsf      = any(strcmpi(varargin,'plotorbrms'));
dp               = getoption(varargin,'dp',DAoptions.dp);
z0               = getoption(varargin,'z0',DAoptions.z0);
DAmode           = getoption(varargin,'DAmode',DAoptions.DAmode);
nturns           = getoption(varargin,'nturns',DAoptions.nturns);
betax0           = getoption(varargin,'betax0',DAoptions.betax0);
betay0           = getoption(varargin,'betay0',DAoptions.betay0);
xmaxdas          = getoption(varargin,'xmaxdas',DAoptions.xmaxdas);
xmindas          = getoption(varargin,'xmindas',DAoptions.xmindas);
ymaxdas          = getoption(varargin,'ymaxdas',DAoptions.ymaxdas);
XmaxDA           = getoption(varargin,'XmaxDA',DAoptions.XmaxDA);
YmaxDA           = getoption(varargin,'YmaxDA',DAoptions.YmaxDA);
npdax            = getoption(varargin,'npdax',DAoptions.npdax);
npday            = getoption(varargin,'npday',DAoptions.npday);
r0               = getoption(varargin,'r0', DAoptions.r0);
nang             = getoption(varargin,'nang',DAoptions.nang);
res              = getoption(varargin,'res',DAoptions.res); 
alpha            = getoption(varargin,'alpha',DAoptions.alpha);

nseeds           = getoption(varargin,'nseeds',10);
tunfams          = getoption(varargin,'tunfams',{'Q1_b3','Q2_b3'});
nittune          = getoption(varargin,'nittune',100); % max n. of iterations for tune mtaching
TolTune          = getoption(varargin,'TolTune',1E-5); % tolerance for tune matching


DAoptions.dp=dp;
DAoptions.z0=z0;
DAoptions.DAmode=DAmode;
DAoptions.nturns=nturns;
DAoptions.betax0=betax0;
DAoptions.betay0=betay0;
DAoptions.xmaxdas=xmaxdas;
DAoptions.xmindas=xmindas;
DAoptions.ymaxdas=ymaxdas;
DAoptions.XmaxDA=XmaxDA;
DAoptions.YmaxDA=YmaxDA;
DAoptions.npdax=npdax;
DAoptions.npday=npday;
DAoptions.r0=r0;
DAoptions.nang=nang;
DAoptions.res=res;
DAoptions.alpha=alpha;

% Parameters for dynamic aperture calculation
%

if (strcmp(DAmode,'grid'))
%
%% Recalculates X0da and Y0da in case the data in DAoptions 
% is not consistent (e.g. is not the same as in a previous MOGA run)
%
    npdax      = DAoptions.npdax;   % number of grid points in x direction is 2*npdax+1
    npday      = DAoptions.npday;   % number of grid points in y direction is  npday+1
    npDA       = DAoptions.npDA;    % total numbr of grid points
    dx = XmaxDA/npdax; % grid stepsize in x [m]
    dy = YmaxDA/npday; % grid stepsize in y [m]
    dxdy = dx*dy;
    X0da = zeros(npDA,1);  % horizontal coordinates of grid points [m]
    Y0da = zeros(npDA,1);  % vertical coordinates of grid points [m]
    k= 1;
    for i=0:npday 
        for j=0:2*npdax
        X0da(k) = -XmaxDA+dx*j;
        Y0da(k) =  dy*i;
        k=k+1;
        end
    end
    DAoptions.X0da=X0da;
    DAoptions.Y0da=Y0da;
    DAoptions.dxdy=dxdy;
end
PC=load('PC.mat');      %to prevent matlab from complaining about variable name being the same as script name.
PhysConst = PC.PC;      %Load physical constants

%% Calculates DAs
if (verbosef)
    tic;
    fprintf('*** \n');
    fprintf('%s Starting DA calculation \n', datetime);
end

DAVs= zeros(nang+1,2*(nseeds+1));
DAs = zeros(1,nseeds+1);
orb0_stds = zeros(6,nseeds+1);
orb_stds  = zeros(6,nseeds+1);
try
   rpara  = atsummary(RING);
   Itunes = rpara.Itunes;
   etax   = rpara.etax;
   if (isnan(z0))
       if (check_6d(RING))
        z0 = PhysConst.c*(rpara.syncphase-pi)/(2*pi*rpara.revFreq*rpara.harmon); %if z0 not given choose the synchronous phase
       else
        z0=0.0;
       end
       DAoptions.z0=z0;
   end
catch ME
     fprintf('%s Error in calcDAdist \n', datetime);
     fprintf('Error message was:%s \n',ME.message);
     DAav=nan;
     DAstd=nan;
     DAdist.inputs.RING=RING;
     DAdist.inputs.ErrorModel=ErrorModel;
     DAdist.outputs.DAav=DAav;
     DAdist.outputs.DAstd=DAav;
     DAdist.outputs.DAstd=DAstd;
     DAdist.outputs.orb0_stds=orb0_stds;
     DAdist.outputs.orb_stds=orb_stds;
     return
end

for i=1:nseeds+1
 if (verbosef)
     fprintf('%s Iteration n. %4d \n', datetime, i-1);
 end

 if (i>1)
     RINGe=applyErrorModel(RING,ErrorModel);
     if (corrorbf) 
         try
            if (verbosef)
                fprintf('%s Correcting orbit \n', datetime);
            end
            [RINGe, orb0, orb] = calcOrb(RINGe,'correct');
            for j=1:6
                orb0_stds(j,i)=std(orb0(j,:));
                orb_stds(j,i)=std(orb(j,:));
            end
         catch ME
             fprintf('%s calDAdist: Error in orbit correction ', datetime);
             fprintf('Error message is %s', ME.message);
             DAs(i)=NaN;
             break;
         end
     end
     if (corrtunf)
         try
           rpara=atsummary(RINGe);
           Itunese=rpara.Itunes;
           if (verbosef)
           fprintf('%s Fitting tunes from [ %5.3f %5.3f ] to [ %5.3f %5.3f ] \n',...
              datetime, Itunese(1), Itunese(2),Itunes(1),Itunes(2));
           end
           [RINGe, its, penalty_tune]= fittuneRS(RINGe, Itunes,...
                      tunfams{1}, tunfams{2}, nittune, TolTune,'Y');
           if (verbosef)
              fprintf('%s Tune fit complete with penalty = %6.2e after %5d iterations \n', datetime, penalty_tune, its);
           end
         catch ME
             fprintf('%s calDAdist: Error in tune correction \n', datetime);
             fprintf('Error message is %s \n', ME.message);
             DAs(i)=NaN;
         end
     end
 else
     RINGe=RING;
 end
 
 try
   if (strcmpi(DAmode,'border'))
    [DAs(i), DAVs(:,2*i-1:2*i)] = calcDA_raw(RINGe,DAoptions,etax,rpara.beta0(1),rpara.beta0(2));
   else
    [DAs(i),~] = calcDA_raw(RINGe,DAoptions,etax,rpara.beta0(1),rpara.beta0(2));
   end
 catch ME
     fprintf('%s Error in calcDAdist \n', datetime);
     fprintf('Error message was:%s \n',ME.message);
     DAs(i)=NaN;
 end
end
DAav  = mean(DAs);
DAstd = std(DAs);

%% Collects output structure data
DAdist.inputs.RING=RING;
DAdist.inputs.nseeds=nseeds;
DAdist.inputs.ErrorModel=ErrorModel;
DAdist.inputs.corrorb=corrorbf;
DAdist.inputs.corrtun=corrtunf;
DAdist.inputs.nittune=nittune;
DAdist.inputs.TolTune=TolTune;
DAdist.inputs.tunfams=tunfams;
DAdist.outputs.DAoptions=DAoptions;
DAdist.outputs.DAVs=DAVs;
DAdist.outputs.DAav=DAav;
DAdist.outputs.DAstd=DAstd;
DAdist.outputs.orb0_stds=orb0_stds;
DAdist.outputs.orb_stds=orb_stds;

if(verbosef)
    fprintf('DA calculation complete \n');
    toc;
end

%% Plots DA Distribution and rms orbits
if (plotf)
    if (verbosef)
        fprintf('Plotting DA... \n');
        if (plotorbrmsf)
            plotDAdist(DAdist,'verbose','plotorbrms');
        else
            plotDAdist(DAdist,'verbose');
        end
    else
        if (plotorbrmsf)
            plotDAdist(DAdist,'plotorbrms');
        else
            plotDAdist(DAdist);
        end
    end
end

%%
